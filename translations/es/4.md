# Capítulo 4

# La red de Monero

En este capítulo, aprenderás los conceptos claves detrás de la tecnología de la cadena de bloques, y cómo los mineros de Monero mantienen el libro contable seguro. Empezaremos por explicar la estructura de _bloques_, la forma en la que están enlazadas en una _cadena_ a prueba de falsificaciones, y cómo los mineros usan la _prueba de trabajo_ (_proof of work_) para llegar al _consenso_ de una versión confirmada del libro contable. En el tópico de minero, discutiremos la fuente de nuevos moneroj, y cómo las monedas son agregadas en el ecosistema. Hacia el final del capítulo, «mojaremos los dedos de los pies» en algunos conceptos de criptografía (_hashes_ y _nonces_) para realmente entender el verdadero proceso de minado.

## 4.1 La anatomía simplificada de un bloque

En el capítulo previo se discutió cómo las transacciones son construidas. En resumen, tu monedero redacta un mensaje con instrucciones para transferir una de tus salidas a un nuevo destinatario. La información sensible en el mensaje (remitente, destinatario, monto) es ocultada criptográficamente, antes que tu monedero autorice el mensaje al firmarlo digitalmente con tu clave privada.

En este capítulo, aprenderás cómo el mensaje de la transacción es procesado para promulgar la transferencia verdadera. Cuando tu monedero transmite este mensaje, la red temporalmente almacena el pedido en una lista de transacciones pendientes conocida como el _pool de memoria_ (_memory pool_). Los mineros de Monero recolectan estas transacciones sin confirmar del _pool_ de memoria y reúne todos ellos en bloques. Un bloque simplificado es mostrado en la siguiente página:

[![Figure 4.1](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i01%20block.png)](https://masteringmonero.com)

> Figura 4.1 — Cada bloque secuencialmente numerado de transacciones deben incluir tanto un _nonce_ y una referencia al _hash_ del bloque anterior.

Cada bloque contiene una serie de transacciones, un enlace criptográfico al bloque anterior (llamado _hash_), y un lugar para que el minero incluya un número especial que complete el bloque (llamado _nonce_, de la contracción _number once_ o _único número_).

Si quieres aprender cómo funcionan los _hashes_ y _nonces_, existe una introducción amigable con ejemplos hacia el final de este capítulo (puedes saltar hacia la última sección del capítulo 4, y leerlo ahora mismo si tienes curiosidad sobre la criptografía). Hay solo dos conceptos que necesitas saber con el fin de entender cómo estas técnicas funcionan para asegurar la cadena de bloques:

* El _hash_ es una característica de seguridad proveyendo que cada bloque sea directamente enlazado a una versión **inalterada** del bloque anterior. Si un atacante intenta falsificarlo en cualquier punto del libro contable, incluso el intento de la más insignificante modificación será descaradamente obvio debido a que los hashes levantarán una bandera roja en cada bloque subsiguiente.

* El _nonce_ es una serie especial que completa el bloque y lo marca como preparado para la cadena de bloques. Es computacionalmente extremadamente dificultoso en encontrar un _nonce_ que satisfaga los requerimientos necesarios para finalizar y sellar un bloque. Los mineros gastar la mayor cantidad de tiempo y energía buscando _nonces_ válidos. Es imposible planificar con anticipación para calcular los _nonces_, por lo que la búsqueda debe comenzar desde cero con cada nuevo bloque. Los _nonces_ no son significativos matemáticamente; sólo es un hilo único de caracteres al azar.

## 4.2 Los nodos son la columna vertebral

### 4.2.1 Los nodos transmiten datos de red a los pares

Hasta ahora, las referencias de «la red de Monero» han sido, principalmente, tratado por encima por sobre los detalles de su composición. ¿Cómo es que tus transacciones, verdaderamente, se propagan a través de esta «red» nebulosa a los mineros y otros usuarios? Miles de nodos de Monero esparcidos a lo largo del planeta están conectados entre sí, compartiendo rápidamente noticias sobre transacciones y bloques.

Estos nodos forman una red de par-a-par (_peer-to-peer network_, o _P2P_), permitiendo una comunicación eficiente y resiliente para los usuarios de Monero. Correr un nodo no requiere de ningún tipo de equipamiento especial o habilidad —si [descargas](https://www.getmonero.org/downloads/) e instalas ahora el programa de Monero, ¡podrás tener tu propio nodo ejecutado antes que termines de leer este capítulo!

[![Figure 4.2](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i04%20nodes.png)](https://masteringmonero.com)

> Figura 4.2 - Monero usa una red de par-a-par distributiva, compuesta de una red de dispositivos voluntarios compartiendo nueva data entre ellos. Los nodos retienen una copia completa de la cadena de bloques y crean la columna vertebral de la red. Dado de ejecutar un nodo requiere de un espacio significativo en el disco, algunos dispositivos (especialmente las billeteras móviles), en cambio, se conectan a un nodo remoto para pedir información y transmitir transacciones.

No hay un nodo «especial» o «súper-nodo» en la red de par-a-par de Monero; todos los nodos (incluyendo el tuyo) son participantes igualitarios, trabajando para compartir recursos y la carga de trabajo. Los nodos son alojados en computadoras de todos los tamaños y formas —_laptops_, computadoras de escritorios, servidores, e incluso máquinas virtuales.

### 4.2.2 Los nodos almacenan la cadena de bloques

Cuando un nuevo nodo es inicializado, primero debe descargar la cadena de bloques entera y verificar los enlaces criptográficos, tales como los _hashes_ y _nonces_. Esta sincronización inicial tal vez tome algunas horas, mientras el nodo construye su propia copia local de la cadena de bloques, mientras confirma la validez de cada transacción y bloque. En vez de descargar la cadena de bloques sobre una única conexión de una fuente central, cada nodo recibe las transmisiones de muchos nodos pares. Los nodos no necesitan identificar o confiar en sus pares, ya que la validez de los datos es confirmada criptográficamente.

Cualquier programa de monedero de Monero (por ejemplo, el GUI de Monero, una aplicación para el celular, etćetera) debe tener acceso a una copia de la cadena de bloques con el fin de llevar a cabo tareas claves como recuperar el historial de las transacciones, calcular balances de cuentas, y crear transacciones. Un monedero no puede crear transacciones antes de comunicarse con un nodo sincronizado, dado que el programa necesita encontrar y concordar las salidas relevantes sin gastar. A pesar de ello, tu dirección puede recibir moneroj estés o no conectado a un nodo sincronizado (simplemente no lo mostrará en tu balance hasta que la billetera descargue y verifique ese bloque).

### 4.2.3 «Nodos locales» _versus_ «nodos remotos»

El proceso de guardar y verificar localmente toda la cadena de bloque, para que tu monedero pueda interactuar con tu propia copia del libro contable, es referido como «correr/ejecutar un _nodo local_». Cuando utilizas este tipo de configuración, tu monedero interactúa únicamente con tu copia personal de la cadena de bloques. Correr un nodo local requiere una buena cantidad de almacenamiento de disco (~60 GB en el momento de escritura), lo cual no es apropiado para todos los dispositivos, tales como teléfonos celulares.

Afortunadamente, el _software_ del monedero puede ser configurado para usar un _nodo remoto_ en vez de tu propio nodo local. Esto significa que tu billetera se conectará al nodo de alguien más y, simplemente, pedirá información acerca de tus salidas. Muchos monederos de Monero para celulares tienen configurado, por defecto, usar un nodo remoto, con el fin de mantener ligera la aplicación. Los monederos Monero GUI y CLI pueden ser configurados para ser usados tanto como nodo local como nodo remoto.

No hay riesgos de seguridad para usar un nodo remoto; tu semilla y tus claves nunca son reveladas, así que el operador del nodo remoto no será capaz de controlar tus fondos o desencriptar cualquier información que sea protegida por las características de Monero como el AnilloTC (ocultando el monto de la transacción) o las direcciones sigilosas (ocultando la dirección del destinatario).

Hay algunas concesiones menores de privacidad que se presentan cuando se utilizan nodos remotos, dado que el operador del nodo está al tanto del tiempo y la dirección IP en el cual tu dispositivo transmite las transacciones o se conecta para las actualizaciones. La próxima tecnología de privacidad Kovri mitigará significativamente estos riesgos. Si tu usas tu propio nodo local, tu monedero escanea tu copia personal de la cadena de bloques para tu historial de transacciones, en vez de confiar en un tercero para recuperar esta información.

## 4.3 Mineros crean nuevos bloques

### 4.3.1 Mineros agregan nuevos bloques en la cadena más larga

Los mineros recolectan transacciones pendientes del _pool_ de memoria, verifican su autenticidad al chequear que las pruebas criptográficas y firmas sean válidas, y revisan que la imagen clave no haya sido usada anteriormente (ver «3.2.3 Anillo de firmas», para rever porqué esto es importante).

Para preparar un bloque, el minero crea una lista de transacciones para ser incluidas, junto con el _hash_ del bloque anterior para proveer un enlace criptográfico. Finalmente, el minero trabaja para encontrar un _nonce_ que pueda ser usado para completar el bloque.

Dado cualquier momento, hay miles de mineros trabajando todos separados (o en _pools_, conocidos como _minería en pool_ o _mining pools_) para encontrar un _nonce_ que complete el bloque actual de transacciones. En el momento en el que el minero o el _pool_ encuentra un _nonce_ para finalizar ese bloque, anuncian su versión al resto de la red. Luego de recibir este bloque completado, los otros mineros y nodos lo anexan a su copia de la cadena de bloques, incrementando la _altura_ de la cadena por un bloque. Las transacciones referencias por el nuevo bloque son removidas del _pool_ de memoria, y los otros mineros descartan su propio trabajo (incompleto) de ese bloque para comenzar a preparar el siguiente.

### 4.3.2 Una tarea difícil asegura estabilidad y justicia

La naturaleza global del ecosistema de Monero y la imprevisibilidad de los retrasos en la transmisión debido a la latencia de la red ocasionalmente causan divisiones momentáneas en la cadena de bloques, si dos mineros independientes de uno al otro completan dos versiones diferentes de un bloque en la misma altura. Suponte que un minero en Sudamérica es el primero en completar un bloque, pero un minero diferente en Europa termina su propia copia antes de recibir la transmisión de Sudamérica. En este caso, el hemisferio oeste podría estar usando temporalmente una diferente cadena de bloque que el hemisferio este. Por un breve momento, existe dos libros contables de Monero compitiendo que quizás tenga pequeñas diferencias (dependiendo de qué transacciones pendientes cada minero ha seleccionado del _pool_ de memoria). ¡Uno quizás pensaría que esto sería una ocurrencia catastrófica!

[![Figure 4.3](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i02%20longest%20chain.png)](https://masteringmonero.com)

> Figura 4.3 - Los mineros compiten para extender la cadena con un nuevo bloque. (Arriba) La cadena de bloques está en una altura «3», por lo que cada minero trabaja en su versión del bloque «4». (Abajo) El bloque «4» fue completado primero por el minero del medio, así que su versión es agregada a la cadena de bloques compartida, y todos los mineros cambian para buscar un _nonce_ para el bloque «5».

Por el contrarios, esta situación es fácilmente resuelta al imponer elegantemente una simple regla: todos los mineros acuerdan en trabajar en el minado del próximo bloque en la cadena más larga. Esto es una pieza clave en el protocolo de consenso descentralizado de Monero, y permite que la red de Monero reúna ágilmente a una sola cadena luego de una división accidental. En vez de tratar de resolver inmediatamente las discrepancias de los bloques, los mineros simplemente continúan trabajando en completar el próximo bloque para su versión.

Dentro de los próximos minutos, uno de los minero resolverá un bloque subsecuente y lo agregará a su cadena. En el momento que esto ocurre, su versión se convierte en la cadena más larga, por lo que los otros mineros y nodos rápidamente adoptan esa copia y desechan los bloques huérfanos alternativos. Cualquier transacción que fue únicamente incluido en el bloque huérfano se mantiene en el _pool_ de memoria para la cadena principal, y será minado en el bloque subsecuente. Al seguir simplemente la cadena más larga creada con el mayor esfuerzo, la red resuelve completamente cualquier división y devuelve el consenso en un único libro contable universal.

### 4.3.3 Los «taxis» de Monero usan un rompecabezas difícil para asegurar la justicia

Validando una serie de transacciones y listándolos en un bloque no es computacionalmente difícil. La tarea que consume tiempo para el minero es encontrar un _nonce_ que le permita completar el bloque. Esto es un rompecabezas diseñado para ser extremadamente dificultoso y resoluble sólo mediante pruebas de soluciones mediante _fuerza bruta_; no existe ninguna forma de acortar el proceso o achicar, matemáticamente, la búsqueda para un _nonce_ válido. Los mineros, simplemente eligen números al azar y los prueban para ver si completan el error, por prueba y error.

¡La presencia de este obstáculo arbitrario pareciera peculiar al principio! Los mineros llevan a cabo un rol crucial y computacionalmente fácil para la red (validar transacciones) pero se requiere realizar una tarea inserviblemente difícil (encontrar un _nonce_) con el fin de enviar sus resultados.

Para entender el razonamiento detrás de esto, considera la Red de Taxis de Monero hipotético con, únicamente, un par de vehículos, y muchísimos taxistas que pueden utilizar temporalmente uno de los taxis si envían una ruta aprobada. A través del día, los potenciales pasajeros pueden llamar y solicitar un viaje a lo largo de la ciudad. Todas las solicitudes de los pasajeros que no han sido recolectados, son almacenados en un _pool_ de solicitudes pendientes en tiempo real.

[![Figure 4.4](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i05%20rides.png)](https://masteringmonero.com)

> Figura 4.4 - En la primera etapa de preparar un plan de ruta, cada conductor mira en el _pool_ de viajes pendientes y dibuja una ruta.

En vez de haber una autoridad central de taxi asignando cada viaje entrante a un auto o chofer, cada conductor mira en el _pool_ y crea su propia lista de 5 - 10 viajes que podría completar en los próximos 30 minutos. ¡Esta parte de la planificación de ruta es fácil y rápida para conductores experimentados! Una vez que un chofer crea una lista de viajes que puede incluir en su próximo «bloque» de viajes, completa una tarea final descrita debajo, y luego envía su ruta a la Red de Taxis de Monero.

Si el chofer ha propuesto una ruta válida para pasajeros reales pendientes, ¡entonces el plan es aprobado! Los pasajers incluidos en el plan del chofer son removidos del «grupo de espera», el chofer revisa un vehícuylo y los pasajeros son transportados a sus destinos. El chofer recolecta las tarifas de cada uno de los pasajeros, y recibe una propina por la Red de Taxis de Monero por ser el primero en enviar un plan completo.

Hasta ahora, ¡esto parecería bastante intuitivo! Los viajes incompletos son listados en un _pool_; donde un chofer envía exitosamente un bloque aprobado de viajes, los pasajeros son transportados a sus destinos y removidos del «grupo de espera».

[![Figure 4.5](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i06%20scrabble.png)](https://masteringmonero.com)

> Figura 4.5 - Luego que los choferes completen la tarea (relativamente) fácil de planificar una ruta, deberán resolver un acertijo dificultoso - en esta analogía, encontrar una manera de reacomodar letras de las direcciones para crear una oración.

Sin embargo, la Red de Taxis de Monero tiene una regla muy peculiar: para que un chofer envíe su plan de bloque de pasajeros a la Red de Monero, primero ellos deberán hacer una tarea inserviblemente dificultosa. Imagina que los choferes deben mezclar todas las letras de las direcciones de los destinos provistos por los pasajeros, y usar algunas de ellas para generar cinco oraciones (> 50 palabras en total) que puede decir cualquier cosa, pero debe tener la correcta gramática en el lenguaje local. Un chofer enviando una ruta planificada debe incluir tanto la lista de viajes como las oraciones sin sentidos («nonce») que coinciden con las letras en los destinos o, caso contrario, su ruta será automáticamente rechazado. Existen múltiples frases válidas que pueden ser construidas a partir de una serie de letras (por ejemplo {a,e,e,e,e,g,i,l,l,m,n,n,o,o,r,s} pueden ser reacomodados para formar frases como «El General Simoneo», «El Monero es genial», «no se elige melonar», «no es el ligero amén», etcétera), y las oraciones resultantes son absolutamente inservibles para cualquier cosa aparte de enviar la serie de viajes para la Red de Taxis de Monero.

Una propiedad de este tipo de tareas, los cuales tienen paralelos en la criptomoneda de Monero, es que es muy difícil encontrar un _nonce_, y muy fácil de verificarlo. Para este escenario de taxis, es muy difícil reacomodar una docena de direcciones a manos en 50 palabras que formen una oración válida. Sin embargo, es algo trivial para alguien más para revisar el _nonce_ resultante y verificar que complete el bloque de viajes. Cuando un chofer envía su _nonce_ en el formato mostrado abajo, puedes confirmar rápidamente que «Apple jam is very bad» es una oración válida, y que las letras están correctamente construídas de los destinos de los pasajers. Esta verificación es casi instantánea, comparada al tiempo que le tomó al chofer en reordenar las letras y encontrar varias oraciones.

[![Figure 4.6](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i07%20nonce.png)](https://masteringmonero.com)

> Figura 4.6 - Encontrar una oración _nonce_ al reacomodar las direcciones es algo difícil y consume mucho tiempo. Sin embargo, la validez de una sumisión es fácil de verificar al chequear rápidamente que sólo usa letras de los viajes incluídos en la ruta.

Un chofer de taxi experimentado sería capaz de planificar la ruta de viaje del listado en menos de 60 segundos, sin embargo, le tomará algunos minutos en reacomodar las letras y encontrar la oración _nonce_ a mano. De hecho, mucho de su esfuerzo en preparar su bloque propuesto de viajes será gastado en encontrar este _nonce_ inservible.

Imagina este proceso desde la perspectiva del chofer de taxi, empezando luego del último bloque aprobado. Tú creas rápidamente una ruta que incluye varios viajes de la lista de viajes pendientes. Luego, empiezas a trabajar furiosamente para reacomodar las letras de los destinos en algún tipo de oración _nonce_. Por algunos minutos, tú y los otros choferes de taxis trabajan en la misma lista de viajes pendientes, cada uno tratando de crear un _nonce_ lo suficientemente largo, con más de 50 palabras. Inesperadamente, un chofer diferente envía una lista de los viajes junto con un _nonce_ completado. Todos los viajes en los que estuviste trabajando ¡desaparecen del _pool_! Debes tirar abajo todo tu trabajo en ese bloque (dado que los pasajeros ya están _en ruta_) y cambiar a un nuevo conjunto de viajes pendientes. El proceso para encontrar un _nonce_ válido para ese conjunto de pasajeros comienza de nuevo desde cero, basado en la nueva serie de letras de sus destinos.

¿Por qué la Red de Taxis de Monero impondría tal tarea tan dificultosa e inservible sobre sus choferes? Es, en realidad, ¡un seguro para garantizar que los clientes sean servidos justamente! Imagina que hay unos pocos choferes de taxis que se comportan no éticamente en algunas formas, quizás ignorar viajes pendientes de ciertas partes de la ciudad, o seleccionando sólo a los pasajeros que irán a las empresas que han sobornado a esos conductores injustos. Sin el requerimiento del _nonce_, estos pequeños grupos de choferes o individuos maliciosos podrían dominar el proceso de selección de viajes para todo el negocio al estar enviando constantemente sus rutas (injustas o excluyentes) apenas un auto esté disponible. En este sentido, ellos podrían tratar sistemáticamente algunos grupos de clientes de forma pobre, lo cual es absolutamente anti-ético para los principios centrales de la Red de Taxis de Monero, el cual está dedicado a servir a todos los pasajeros de forma justa.

La competición de la tarea _nonce_ entre muchos choferes de taxis es crucial para el objetivo de Monero en asegurar que todos los autos y los pasajeros son provistos de forma justa. Asumiendo que todos los choferes de taxi pueden reacomodar las letras a, aproximadamente, la misma velocidad entre ellos, será de alguna forma aleatoria qué chofer tendrá la suerte de encontrar una solución y ser quien envíe primero su bloque de planes. Es improbable que cualquier otro chofer podría ser el primero en enviar múltiples planes de bloques seguido (por ejemplo, ser el primero en encontrar oraciones _nonce_ por varios bloques secuenciales) dado que cada chofer está compitiendo en contra de, y colectivamente superado en número por, todos los otros choferes.

Mucha de la multitud de potenciales choferes serán individuos honestos, enviando planes de bloques de viajes razonables para que la ciudad funcione sin problemas. Si hay algunos choferes maliciosos que desean subir sus planes injustos, la tarea _nonce_ los previene de controlar el sistema entero. Estadísticamente, ellos, ocasionalmente, serán los primeros en encontrar el _nonce_, y por ende podrán subir su plan de ruta excluyente para ese bloque. Sin embargo, el resto de los choferes, muchos de ellos siendo honestos, inmediatamente trabajarán en sus bloques justos para proponer a la siguiente serie de viajes. Debido a la naturaleza aleatoria de quien tenga la suerte en encontrar un _nonce_ en primer lugar, el próximo conjunto de viajes probablemente será realizado por un chofer honeros cuyo plan incorporarán los viajes previamente excluidos. Este sistema de imponer trabajo inútil para aleatorizar qué ruta es aceptada, la Red de Taxis de Monero permite asegurar que una minoría de choferes maliciosos no podrá bloquear a un usuario o grupo de crear los viajes.

La Red de Taxis de Monero, por ende, no tiene ninguna autoridad central que sea responsable o fiable para controlar la actividad de viajes y de asignación. En vez de eso, esta tarea es distribuida a los choferes individuales, empleando esta competición de un _nonce_ inútil para seleccionar aleatoriamente qué propuesta de ruta es aceptada. Esto, estadísticamente, asegura que los autos están frecuentemente asignados a choferes honestos, así la Red de Taxis de Monero tendrá una excelente reputación para proveer un servicio justo a todos los clientes.

Hasta ahora, quizás te estés preguntado ¡cómo esta metáfora extendida de los taxis está relacionada con las criptomonedas del cual se trata este ostentoso libro! Quizás te hayas dado cuenta que la Red de Taxis de Monero descentralizada es una evidente analogía a la red de criptomoneda de Monero, el cual necesita proveer un servicio global justo sin ningún tipo de autoridad central.

Cada viaje corresponde a una transacción de Monero, pendiente en el _pool_ de memoria hasta que es seleccionado por un lugar en un auto/bloque. Los choferes de taxis representan los mineros. Ambos llevan adelante trabajos fáciles e igualmente importantes (los choferes de taxis planean rutas; los mineros recolectan y validan transacciones), aún así están forzados a competir entre los otros choferes/mineros en una tarea _nonce_ dificultosa e inútil. Esta barrera aleatoriza quién lo logra primero - así, distribuyendo estadísticamente muchos de los autos/bloques a los choferes/mineros honestos. Quien quiera que sea el chofer que envía su ruta primero será recompensado con un bonus de la Compañía de Taxis de Monero y una propina por cada uno de los pasajeros que obtuvieron un lugar. De igual manera, los mineros son recompensados con una comisión (llamado _coinbase_ o recompensa de bloque) por haber completado cada bloque, y también recolectan comisiones de las transacciones incluidas en el bloque.

### 4.3.4 Los mineros son pagados por su servicio

Cada vez que un minero mina satisfactoriamente un bloque (es decir, es el primero en encontrar un _nonce_ que completa el próximo bloque en la cadena más larga) es pagado en dos formas diferentes.

1) Primero, el minero recibe una recompensa por contribuir un bloque completo de tansacciones validadas. Esta recompensa de bloque es análogo al bonus que la red de taxis paga a los choferes que enviaron sus rutas completadas. Todos los mineros, luego de recibir y confirmar el bloque resuelto, agregar esta recompensa de bloque a la dirección del minero que ha encontrado primero el _nonce_ válido).

2) Segundo, el minero recolecta comisiones que fueron incluida dentro de las transacciones. Los usuarios de Monero pueden incrementar las chances que un minero incluya su transacción más rápido al incrementar la comisión.

Es un malentendido común pensar que los mineros están «encontrando» o «creando» monedas. En realidad, los mineros simplemente están validando las transacciones, y son pagados por su trabajo con nuevas monedas. Esta introducción de nuevos moneroj es referido como a la _emisión de monedas_.

Cuando Monero fue lanzado, la razón de emisión de monedas era de más de 30 XMR cada 2 minutos. Esta recompensa será suavemente decrementada hasta que llegue a los 0,6 XMR por cada bloque de dos minutos en el año 2022. La continua disminución de Monero está diseñada para proveer un ambiente económico más estable para los mineros, comparado con eventos dramáticos de _halving_ (reducción a la mitad) de otras criptomonedas, cuando la recompensa de bloque es sustancialmente reducido abruptamente. Luego del 2022, la «emisión de cola» de Monero se mantendrá constante, garantizando que minar un bloque será siempre recompensado con 0,6 XMR.

Muchas criptomonedas tienen un capital fijo en la emisión de monedas, con un límite en la oferta máxima. Una vez que la oferta de capital sea alcanzado, no habrá nuevas monedas introducidas para los mineros, los cuales estarán forzados a subsistir enteramente en las comisiones. Por ejemplo, en Bitcoin, este cambio de paradigmas en los incentivos ocurrirá en el año 2140, cuando la oferta alcance los 21 millones de Bitcoin, y deje de incrementarse más allá de esa cantidad. Este enfoque es frecuentemente promocionado como un beneficio para mantenerse «deflacionario», sin embargo estos argumentos están basados, a menudo, en combinando los conceptos de una oferta monetaria inflacionaria con un uso diferente de la palabra «inflación» para describir una disminución indeseable en el poder adquisitivo de una moneda.

El incremento anual de la oferta de Monero en 0,6 XMR, debido a la emisión de cola, es menor del 1% por año. Mientras que los desarrolladores crearon la emisión de cola para incentivar a los mineros de largo plazo, un producto ordenado es su fácil comparación con los sistemas financieros respaldados por activos. El incremento del ratio de la oferta por la emisión de cola es comparable al incremento de la oferta anual de oro globalmente, el cual, para las civilizaciones modernas, ha sido históricamente la más pura y la más estable forma de dinero. Dado que los mineros siempre podrán recolectar las comisiones, las recompensas de bloque garantizadas proveen una mayor estabilidad financieron para muchos de los mineros en el largo plazo. Este contrato social asegura que los mineros permanecerán incentivados de usar sus equipos para asegurar la red de Monero.


[![Figure 4.7](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-4.3.3%20rewards.png)](https://masteringmonero.com)

> Figura 4.7 - Un minero recive dos tipos de pagos cada vez que minan un bloque: 1) las comisiones incluidas en cada transacción, y 2) una recompensa de bloque consistiendo en nuevos moneroj acuñados.

## 4.4 Sistemas de Prueba de Trabajo

Ahora nos alejaemos de la analogía de los taxis y discutiremos directamente el sistema que asegura la justicia en Monero. Este proceso de acomplar funciones importantes de red con la búsqueda de un _nonce_ inservible es referido como el sistema de _Prueba de Trabajo_ (_Proof of Work_). Muchas de las criptomonedas son construidas bajo un consenso PdT (de las siglas _Prueba de Trabajo_, o _PoW_ en inglés), y existen diferencias entre varias implementaciones con diferentes características. Sin embargo, todas ellas comparten un tema en común al forzar la descentralización al requierir validación para entregar un bloque con un _nonce_. A veces, el mismo _nonce_ es referido como la «prueba de trabajo», refiriéndose a la pieza de dato que fue difícil de crear/encontrar y fácil de verificar, tales como los anagramas de los choferes de taxi.

Los mineros miden qué tan rápido pueden trabajar para minar bloques en «hashes por segundo», abreviado como H/s. Cada minero puede medir su _hashrate_ el cual varía dependiendo del equipamiento que están usando para minar. El _hashrate_ de la red se refiere al _hashrate_ total de todos los mineros trabajando para preparar los bloques.

### 4.4.1 Beneficios

#### 4.4.1.1 Resistencia a la censura

En sistemas PdT, la competición de la búsqueda del _nonce_ descrito arriba aleatoriza qué versión del minero es aceptado como el último bloque en la cadena más larga. Como fue mencionado en la analogía del taxi, el marco de trabajo del PdT previene efectivamente la censura. Algunos mineros maliciosos en la red de Monero podría tratar de proveer un trato preferencial o excluir ciertas transacciones en el _pool_ de memoria, sin embargo un minero honesto de Monero simplemente incluirá esas transacciones en el próximo bloque.

#### 4.4.1.2 Prevención al ataque de «gasto doble»

Hay otro desafío en la cadena de bloques resuelta por los sistemas PdT que no fue incluida en la analogía de los taxis. Específicamente, un minero malicioso trataría de realizar un «gasto doble». Esto se refiere a un ataque donde el minero crea un bloque alternativo para deshacer sus transacciones pasadas y robar el dinero para ellos mismos. El ataque tendría que proceder de esta manera:

* El minero malicioso Martín transmite una transacción enviando alguno de sus moneroj a la víctima «Valeria».
* Cuando la transacción Martín >> Valeria es minado en la cadena de bloques, Valeria cree que se le ha pagado a ella.
* Martir toma cualquier cosa que él estaba comprando a Valeria...
* ... Luego Martín mina una versión diferente del bloque que originalmente contenía la transacción Martín >> Valeria.
* En la versión alternativa de martín, ¡la transacción de Valeria no existe! En vez de eso, su segunda versión contiene una transacción que envia esos moneroj a uno de sus monederos (Martín >> Martín) en vez de Valeria.
* Si Martín puede minar rápidamente los bloques suficientes para hacer su cadena la más larga, entonces la red aceptará su realidad alternativa. En la práctica, la inviabilidad de este paso previene que el ataque de doble gasto ocurriese.
* Dado que la imagen clave de la salida de Martín aparece en la cadena (ahora asociado con la transacción hacia sí mismo), la red no aceptará la transacción Martín >> Valeria como válido dado que la imagen clave asociada con esa salida ya ha sido gastada.

En este punto, Martín se ha sido con lo que sea que haya comprado a Valeria, y también ha recuperado los moneroj que inicialmente usó para pagarle.

Afortunadamente, los sistemas PdT previenen de un atacante de sostener este tipo de ataque de doble gasto, al limitar la velocidad en el que pueden generar bloques. Recuerda que los mineros siempre siguen la cadena de bloques más larga, por lo que el minero malicioso tendrán que cambiar el bloque con la transacción previa y luego re-minar cada bloque que le sigue, lo suficientemente rápido para alcanzar la longitud de la cadena principal. Dado que el minero malicioso estará trabajando en solitario para generar los bloques alterados, en contra del _hashrate_ entera de toda el resto de la red manteniendo el libro contable original, el atacante nunca podrá alcanzarlos. Este tipo de ataque podría ser factiblemente satisfactorio si el minero malicioso tiene el suficiente poder de cómputo que el resto de la red combinado. Por esta razón, el término «ataque del 51%» es generalmente usado para indicar que algún tipo de actividad maliciosa requeriría el _hashrate_ mayoritario.

[![Figure 4.8](https://raw.githubusercontent.com/monerobook/monerobook/master/resources/img/mm-c04i03%2051%20attack.png)](https://masteringmonero.com)

> Figura 4.8 - El minero deshonesto en el fondo intenta un ataque de doble gasto al crear una versión diferente de un bloque ya minado. El resto de los mineros honestos trabajando juntos producen bloques más rápidos que el minero malicioso, así que la cadena del atacante, con la transacción alternativa, es descartada.

Una criptomoneda con más mineros y un _hashrate_ total de red más grande hará más dificultoso el ataque en este sentido, dado que el minero malicioso debe tener más poder de cómputo que el resto de la red global. Incrementando el total del _hashrate_ al incluir más mineros ayuda a asegurar la red contra lo ataques.

### 4.4.2 La «dificultad» ajusta el tiempo entre bloques

La red de Monero apunta a agregar un nuevo bloque en la cadena aproximadamente cada dos minutos. Con cada bloque minado, algunas transacciones son movidas desde el _pool_ de memoria pendiente en la cadena de bloques confirmada. Si el promedio del tiempo de bloque se vuelve muy largo, las transacciones serán demasiadas lentas para ser confirmadas. Si el promedio del tiempo de bloque se vuelve muy corto, entonces la red podría desincronizarse más seguido.

La red influencia qué tan rápido los bloques son minados al ajustar la dificultad del rompecabezas del _nonce_. Mientras más mineros se unan a la red con el tiempo, su poder colectivo de adivinar (_hashrate_) resulta en bloques siendo completados más frecuentemente (conceptualmente: si duplicas la cantidad de personas buscando algo, el grupo probablemente lo encontrará en la mitad del tiempo). Esto podría causar, estadísticamente, que los mineros encuentren bloques más rápidos que el objetivo del tiempo de bloque de dos minutos. Para compensar esto, la dificultad del rompecabezas se incrementa, lo cual significa que se tardará mástiempo en encontrar un _nonce_ que logre los requerimientos arbitrarios. De igual manera, la dificultad se puede ajustar para ser más fácil si el poder de minado decrece, causando que los bloques sean completados muy infrecuentemente.

En la analogía de la red de taxis de la sección anterior, la dificultad de la tarea del reacomodamiento de letras podría ser similarmente ajustada arbitrariamente al requerir de más o menos palabras en la oración _nonce_. Si 20% de los choferes de taxis (mineros) no participan en un día, entonces tomará más tiempo, en promedio, para crear bloques de planes de ruta (completados con _nonces_) para ser enviados, por lo que algunos autos podrían estar parados sin ningún conductor. Para corregir esto, los choferes de taxis acordarían en bajar los requerimientos del _nonce_ de 50 a 40 palabras. Esto pondría a los choferes de vuelta en sincronía con la disponibilidad de autos.

La dificultad se incrementa proporcionalmente con el _hashrate_ total de la red para mantener constante el flujo de bloques.

### 4.4.3 El algoritmo CryptoNight

Monero usa una variación del algoritmo PdT CryptoNight, el cual es significativamente diferente que los sistemas usados por mucha de las otras criptomonedas. Una de las características que definen a Monero es el uso de una función de PdT que es dificultosa para optimizar con equipamiento de minado especializado.

En mucho de los contextos, «optimización» es algo bueno, así que podrías estar sorprendido que el algoritmo de PdT de Monero obstaculice intencionalmente la aceleración de las velocidades de minería. Esto se debe a que la habilidad de crear equipamiento de minado con sobrepotencia puede llevar a una peligrosa centralización de mineros. Estos riesgos están perfectamente ilustrados en la historia de minado de Bitcoin.

#### 4.4.3.1 Contexto: La historia de minado de Bitcoin

Cuando las criptomonedas entraron a la escena con la aparición de Bitcoin en el año 2009, el minado ocurrió exclusivamente en las CPUs de las computadoras. Dado que la dificultad de minado de la red se ajusta al _hashrate_ total, el minado de las CPU eran adecuadamente rentable en los primeros días. Los mineros de CPU tenían un poder de _hashing_ en el orden de los 1.000.000 H/s, escrito como 1 MH/s (un mega-hash por segundo) para la conveniencia.

Rápidamente, las tarjetas gráficas fueron reutilizadas para minar criptomonedas. Las GPUs son capaces de atacar los problemas de minados en órdenes de magnitud más rápidas, alrededor de 100 MH/s. Dado que la dificultad ajustada se basaba en los mineros de GPU, los mineros de CPU no podían competir (es decir, la recompensa de minado era insuficiente para pagar el equipamiento y los costos de electricidad).

Más adelante, los circuitos integrados de aplicaciones específicas (_application-specific integrated circuits_ o por sus siglas en inglés, ASIC) fueron construidos con el único propósito de minar Bitcoin. Estos dispositivos especiales son bastante caros, y minan miles de veces más rápido que una GPU - más de 1.000.000 MH/s. Por ahora, la dificultad de la red de Bitcoin se ha incrementado para acomodarse a los ASICs, consecuentemente sacando a los mineros de CPU y GPU fuera del negocio.

Bitcoin fue inicialmente lanzado con la visión que cualquiera en el mundo con una computadora pueda comenzar a minar para asegurar la red y obtener algunos Bitcoin como recompensa. Desafortunadamente, la creación y proliferación de los ASICs terminaron muy efectivamente con este sueño. Si deseas comenzar a minar Bitcoin ahora mismo, deberás obtener un ASIC por cientos o miles de Euros.

Esta toma de control de los ASIC puso a la vasta mayoría de mineros de Bitcoin fuera del negocio. La red comenzó su existencia segura por los montones de _geeks_ de la informática esparcidos a lo largo del globo, todos participando en su computadora personal y su tarjeta gráfica. Tristemente, esta verdadera descentralización de Bitcoin es una era pasada. Ahora, la red está dominada por varias corporaciones grandes con granjas masivas de ASIC, los cuales se han convertido efectivamente en la columna vertebral de Bitcoin.

#### 4.4.3.2 ASICs permite la peligrosa centralización

Dado que muchas de las principales criptomonedas están dominadas por mineros de ASIC, vale la pena darle una consideración al tópico y a sus riesgos. La centralización ocurre en dos formas: los ASICs son sólo producido por unas pocas compañías (centralización de la fabricación) y el minado subsecuente tiende a ser limitado a unas pocas granjas enormes (centralización de la minería).

La centralización de la creación de ASICs y el minado a unas pocas enormes corporaciones permiten a los hackers, atacantes, y gobiernos ejercer una influencia desproporcionalmente grande sobre la red y sus operaciones. Esto comenzó a anular muchos de los beneficios de la descentralización. Por ejemplo:

El acceso universal al minado floreció en los días del minado de CPU y GPU, los cuales usan más que nada _hardware_ no regulado de propósito general. Sin embargo, minar ahora requiere de _hardware_ especializado, lo cual está en un riesgo mucho más grande de regulación y control. Es posible que algunos gobiernos impongan prohibiciones o requieran licencias para fabricar/adquirir ASICs.

La resistencia a la censura es debilitada si la mayoría del poder de _hash_ de Monero es controlada por grandes granjas de minado que pueden presionar en la confirmación o en la censura de ciertas transacciones. Sería dificultoso ejercer esta influencia sobre una colección global de mineros amateur, y mucho más fácil de imponer este tipo de actividad en corporaciones centralizadas de minería.

La resiliencia de la red podría ser catastróficamente socavada si un fabricante malicioso (o uno que sigue las órdenes del gobierno) incluyera un interruptor de apagado de ASIC secreto para controlar remotamente o apagar el equipamiento d minado. Esto crea un único punto de falla, cuya activación podría matar instantáneamente mucho del _hashrate_ de la red. Esto hundiría a la red en un súbito estado vulnerable con un _hashrate_ dramáticamente reducido para asegurar la moneda. Este riesgo es mucho más grande si un pequeño número de fabricantes de ASIC controla la mayoría de la producción.

La toma de control de los ASIC en Bitcoin está completado. Mientras hay algunos mineros de tiempo parcial con ASIC trabajando en pools, las enormes granjas de minados dominan el _hashrate_ de la red. Preocupantemente, la mayoría de los ASICs para Bitcoin están diseñados, fabricados y enviados por un único fabricante - en un marcado contraste con los primeros días de Bitcoin, donde los mineros usaban cada marca, modelo y «sabor» de CPU y GPU para minar. La prevalencia de los ASIC sería mucho menos riesgoso si existiese un mercado diverso y competitivo de ASIC.

#### 4.4.3.3 Monero resiste activamente los ASICs

Dado los principios subyacentes de igualdad, la comunidad de Monero no aprueba los ASIC y su inevitable centralización de poder de minado. Mientras los algoritmos _hash_ basados en CPU (SHA-256) usado por Bitcoin están sujetos a las optimizaciones de ASIC, Monero disuade el desarrollo de ASIC al usar algoritmos basados en memoria (CrypyoNight) que es difícil de acelerar.

Consecuentemente, el minado de CPU y GPU son más factibles para Monero, incluso en el año 2018. Hay, actualmente, miles de milles de dispositivos existentes (cualquier CPU moderno x86 y muchas GPUs) que son capaces de minar Monero, por lo que el proceso es accesible a cualquier individuo conectado a internet. De hecho, ¡incluso es posible minar Monero en un navegador web desde cualquier teléfono o computadora!

A principios de marzo del 2018, la comunidad de Monero quedó paralizada al darse cuenta que los ASICs de CryptoNight habían sido secretamente producida, ¡y estaban minando Monero! Estos dispositivos perpetraron para minar Monero 25 veces más rápidos que las principales GPUs, y un análisis retrospectivo del _hashrate_ sugiere que obtuvieron casi la mitad del _hashrate_ de la red de Monero a fines de 2017 y a principios de 2018.

Dado que el algoritmo CryptoNight fue diseñado como una función de memoria específicamente para «cerrar la brecha entre los mineros de CPU (mayoritarios) y GPU/FPGA/ASIC (minoritarios)», la existencia de estos ASICs fue un descubrimiento inesperado. Mientras los autores de CryptoNote observaron que «es apropiado que algunos usuarios puedan tener ciertas ventajas sobre otros» ellos propusieron que «su inversión debería crecer, al menos, linearmente con la potencia». Naturalmente, una nueva computadora o una tarjeta gráfica más linda minará más efectivamente que el equipamiento más viejo, pero los ASICs crearon una distribución extremadamente desproporcionada de _hashrate_.

La comunidad de Monero reaccionó rápidamente, tomando pasos proactivamente para mitigar el minado de ASIC antes que la existencia de estos dispositivos fuera completamente confirmado. En la primavera de 2018, la rutina de mejora de Monero incluyó un pequeño retoque al algoritmo de CryptoNight, diseñado para afectar a los ASICs diferente que a los mineros con GPU/CPU. Esta pequeña variación no cambió la dificultad o comportamiento del algoritmo, por lo que los mineros de CPU/GPU pudieron ajustar fácilmente a la nueva variante cuando mejoraron con la red.

Los ASICs, por el otro lado, fueron fundamentalmente incapaces de adaptarse a nuevas (menores o mayores) variaciones. Uno podría pensar sobre los ASICs como trabajadores que están entrenados para hacer una tarea extremadamente rápida, pero no pueden aprender a hacer otra cosa. El algoritmo para ser ejecutado es físicamente grabado en los circuitos del ASIC, por lo que no pueden ser reprogramados o reutilizado.

Cuando los retoques menores de CryptoNote fueron implementados en el bloque 1.546.000, los ASICs se volvieron instantáneamente incompatibles con la red, y aproximadamente la mitad del _hashrate_ total se desvaneció. Dado que los ASICs fueron incapaces de ajustarse para procesar los bloques con un algoritmo modificados, cualquier bloque que producían eran, ahora, inmediatamente rechazados por la red de Monero como inválido.

Siendo por el momento, pareciera que la red de Monero ha mitigado exitosamente la amenaza inesperada de los ASIC. Para continuar desalentando a los ASICs, Monero ahora cambia levemente el algoritmo de minado con cada actualización de la red. También están explorando enteramente nuevos algoritmos para salvaguardar la red de los ASICs en el largo plazo. Dado que Monero lleva adelante una rutina de «hard-fork» cada 6 meses, esto debería desincentivar cualquier intento de producir ASICs para Monero, dado que cada costoso y prolongado rediseño podría dejarlo obsoleto.

### 4.4.4 Breve nota sobre las alternativas a PdT

Existen sistemas alternativos para mantener la justicia además de la prueba de trabajo; ejemplos incluyen la prueba de participación (_proof of stake_), prueba de espacio (_proof of space_), prueba de ancho de banda (_proof of bandwidth_) e incluso híbridos entre múltiples tipos. Cada sistema tiene sus propias ventajas y desventajas. La prueba de trabajo es actualmente el mecanismo de consenso más ampliamente usado y probado, y es actualmente el único sistema utilizado por Monero.

## 4.5 Conceptos criptográficos para la prueba de trabajo

A lo largo de este capítulo, nos hemos enfocado en la funcionalidad de los _hashes_ y los _nonces_, describiéndolos primariamente a través de las analogías. Si quieres aprender cómo realmente funcionan, el resto del capítulo introduce el principio real criptográfico.

### 4.5.1 Hashes (concepto general)

Las funciones _hash_ son una herramienta criptográfica que puede digerir cualquier dato de entrada, y produce una huella única en su salida. Estos algoritmos están diseñados para que cualquier alteración en la entrada, incluso en cambios muy pequeños, resultase en una salida enteramente diferente. El término _hash_ puede ser usado para referirse tanto a la función misma como en la salidad para una entrada particular.

Agregar, remover o cambiar incluso un solo caracter resultará en un _hash_ totalmente diferente. Considera el mensaje «Por favor, envía 50 euros a Jen.» Podemos ejecutar el hilo a travé de unos de estos algoritmos para producir su hash c250d3fc91236856. La tabla por debajo muestra cómo la salida del _hash_ cambia dramáticamente con cualquier modificación en la entrada:

Entrada | Salida | Comentario
--- | --- | ---
Por favor, envía 50 euros a Jen. | c250d3fc91236856 | Mensaje original
Por favor, envía 500 euros a Jen. | 19347aff8ab8a403 | Se agregó un cero extra al monto.
Por favor, envía 60 euros a Jen. | b7a5cb76d60e2c93 | Se cambió el «5» por un «6»
Por favor, envía 50 euros a Jon. | 666eb7865763fc4e | Se cambió el destinatario a «Jon»
Por favor, envía 50 euros a Jen. | c250d3fc91236856 | ¡Misma entrada = misma salida!

     Los ejemplos de las salidas son los primeros 16 caracteres de cada entrada del _hash_ SHA-256
	$ echo {input} | sha256sum | cut -c1-16

Las funciones _hash_ son fuertemente utilizadas en muchas de las características de seguridad de las criptomonedas. Las funciones criptográficas _hash_ son diseñadas para ser resistente a las colisiones, lo que significa que es difícil encontrar dos mensajes de entrada que colisionen para producir la misma salida digerida. Esto es central para la inmutabilidad (naturaleza a prueba de manipulaciones) de la cadena de bloques, dado que cualquier intento para cambiar los datos en un bloque pasado resultará en una salida _hash_ completamente diferente para ese y los siguientes bloques.

Esta noción de una base de datos expansible únicamente con añadiduras, con cada grupo de entradas criptográficamente asegurada por _hashes_ al bloque anterior, es un concepto clave detrás de la revolución de la cadena de bloques.

### 4.5.2 Nonces (concepto general)

El término _nonce_ refiere a un rompecabezas que no es inherentemente físico/matemáticamente significativo. Por ejemplo, considera las siguientes preguntas «para rellenar los espacios en blanco» que un profesor podría darle a sus estudiantes:

Acertijo A) La palabra en Esperanto para «m\_\_\_\_\_» inspiró al nombre «Monero».
	Respuesta aceptable: «moneda».
Acertijo B) 1 kilogramo es igual a «\_\_\_\_» gramos.
	Respuesta aceptable: 1000
Acertijo C) Este número primo de tres dígitos «3\_\_» no repite ningún dígito.
	_Nonces_ aceptables: cualquiera de {307, 317, 347, 349, 359, etc...}
Acertijo D) Este número primo de cinco dígitos "7\_\_\_\_" no repite ningún dígito.
	_Nonces_ aceptables: cualquiera de {71263, 72169, 73609, 74869, etc...}

Los acertijos A y B son, ambos, significantes, y cada uno tiene una única respuesta correcta (A: «moneda»; B: «1000») que el estudiante querrá recordar para problemas futuros. Por ende, estas respuestas no son consideradas «_nonces_»

No obstante, los acertijos C y D son, ambos, tareas «de mucho trabajo» que son difíciles de resolver, y no contribuyen a la profundidad de ningún problema real. Existen múltiples soluciones en el que todas ellas satisfacen los requerimientos del _nonce_; para la pregunta C, la respuesta «359» es igualmente válida que «307».

Un estudiante que tarda una hora probando varios números para encontrar la respuesta «359» para el acertijo C debe comenzar a buscar un _nonce_ válido desde el principio luego de enfrentarse a cada variación del acertijo, por ejemplo: «Este número primo de tres dígitos «6\_\_» no repite ningún dígito.»

Si sólo tuvieras un lápiz y un papel (o incluso una calculadora, ¿resolverías el acertijo C o el D? Probablemente el C, dado que es más probable que encuentres una respuesta de un número de tres dígitos válidos que una de 5 dígitos. Puedes ver cómo la dificultad de problema puede ser ajustada arbitrariamente al cambiar cuántos dígitos son requeridos.

## 4.6 Resumen del concepto de PdT

Las criptomonedas usan el _hash_ de cada bloque para asegurar que su contenido no ha sido cambiado, dado que modificar un solo caracter se volvería instantáneamente obvio debido al _hash_ radicalmente diferente (el cual se propaga a través de los bloques subsecuentes). El _hash_ de un bloque incluye todo su contenido: transacciones, encabezados, el _hash_ del bloque anterior, y un campo para el _nonce_.

Para trabajar en completar un bloque, los minero deben adivinar aleatoriamente valores para el _nonce_, intentando buscar uno que cause que el _hash_ de todo el bloque produzca una salida debajo de un cierto umbral, el cual es determinado por la actual dificultad de red. Dado que es imposible predecir cómo el cambio en la entrada de una función _hash_ afectará su salida, los mineros deben adivinar por fuerza bruta _nonces_ aleatorios por prueba y error hasta encontrar aquel que produzca una salida de _hash_ que satisfaga la dificultad actual de la red.

La red aumenta o disminuye este umbral para influenciar la dificultad de minado, para mantener el tiempo del bloque de 2 minutos independiente de los cambios en el _hashrate_ total.
